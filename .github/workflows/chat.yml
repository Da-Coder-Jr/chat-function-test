# .github/workflows/ai-assistant.yml
name: AI Assistant

on:
  issue_comment:
    types: [created] # Trigger only on new comments

permissions:
  # Required for reading/writing issues and comments
  issues: write
  # Required for adding reactions to comments
  reactions: write
  # Required for checking out code, reading files, committing changes
  contents: write
  # Required for creating pull requests
  pull-requests: write
  # Potentially needed depending on the exact AI API/integration used
  # id-token: write # Example if using OIDC for auth

jobs:
  ai_assistant_job:
    runs-on: ubuntu-latest
    # Prevent recursive loops if the bot mentions itself or replies to its own comments
    if: github.event.sender.type != 'Bot'

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs

      - name: Checkout repository
        uses: actions/checkout@v4
        # Fetch history needed for creating branches/PRs correctly
        with:
          fetch-depth: 0

      - name: Run AI Assistant Logic
        uses: actions/github-script@v7
        id: assistant # Give this step an ID to access its outputs if needed later
        env:
          # Store these in GitHub Secrets for your repository or organization
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          POLLINATIONS_API_KEY: ${{ secrets.POLLINATIONS_API_KEY }} # <-- Add Pollinations API key secret
          # Define your bot's username (including @)
          BOT_USERNAME: '@your-bot-username' # <-- CHANGE THIS to your bot's actual handle
          # Define the API endpoint for Pollinations AI chat completions
          POLLINATIONS_API_ENDPOINT: 'https://api.pollinations.ai/chat/completions' # <-- VERIFY/CHANGE this endpoint
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process'); // For running git commands

            // --- Configuration ---
            const botUsername = process.env.BOT_USERNAME;
            const apiKey = process.env.POLLINATIONS_API_KEY;
            const apiEndpoint = process.env.POLLINATIONS_API_ENDPOINT;
            const systemPromptPath = 'system-prompt.md'; // Path to your system prompt file
            const maxCodeSnippetLength = 4000; // Limit code snippet length to prevent huge prompts

            // --- Context ---
            const { payload, issue, repo } = context;
            const commentBody = payload.comment.body;
            const issueNumber = issue.number;
            const commentId = payload.comment.id;
            const commenterLogin = payload.comment.user.login;
            const repoOwner = repo.owner;
            const repoName = repo.repo;

            // --- Helper Functions ---
            async function postComment(body) {
              await github.rest.issues.createComment({
                owner: repoOwner,
                repo: repoName,
                issue_number: issueNumber,
                body: body
              });
            }

            async function addReaction(reaction = 'eyes') {
              try {
                await github.rest.reactions.createForIssueComment({
                  owner: repoOwner,
                  repo: repoName,
                  comment_id: commentId,
                  content: reaction
                });
              } catch (error) {
                console.warn(`Could not add reaction: ${error.message}`);
              }
            }

            function readFileContent(filePath) {
              const fullPath = path.resolve(filePath);
              // Basic security check: ensure the path is within the checked-out repo
              if (!fullPath.startsWith(path.resolve('.'))) {
                  throw new Error(`Access denied to path: ${filePath}`);
              }
              if (fs.existsSync(fullPath)) {
                  const content = fs.readFileSync(fullPath, 'utf8');
                  if (content.length > maxCodeSnippetLength) {
                    return content.substring(0, maxCodeSnippetLength) + '\n... [truncated]';
                  }
                  return content;
              } else {
                  throw new Error(`File not found: ${filePath}`);
              }
            }

            async function createPullRequest(branchName, title, body, changes) {
              console.log(`Attempting to create PR: ${title} from branch ${branchName}`);
              try {
                // 1. Create and switch to a new branch
                execSync(`git checkout -b ${branchName}`);
                console.log(`Created branch ${branchName}`);

                // 2. Apply changes (overwrite files)
                for (const change of changes) {
                  const filePath = change.file;
                  const fileContent = change.content;
                  const dir = path.dirname(filePath);
                  if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir, { recursive: true });
                  }
                  fs.writeFileSync(filePath, fileContent);
                  console.log(`Applied changes to ${filePath}`);
                }

                // 3. Stage changes
                execSync(`git add .`); // Add all changes made

                // 4. Commit changes
                // Configure git user for the commit
                execSync(`git config user.name "${process.env.BOT_USERNAME || 'github-actions[bot]'}"`);
                execSync(`git config user.email "${process.env.BOT_EMAIL || 'github-actions[bot]@users.noreply.github.com'}"`); // Provide a default or configure via env var
                const commitMessage = `AI Assistant: ${title}\n\nGenerated for issue #${issueNumber}`;
                execSync(`git commit -m "${commitMessage.replace(/"/g, '\\"')}"`); // Escape quotes in commit message
                console.log(`Committed changes`);

                // 5. Push the new branch
                execSync(`git push origin ${branchName}`);
                console.log(`Pushed branch ${branchName} to origin`);

                // 6. Create the Pull Request
                const pr = await github.rest.pulls.create({
                  owner: repoOwner,
                  repo: repoName,
                  title: title,
                  head: branchName,
                  base: context.payload.issue.pull_request ? // Check if issue is a PR itself to determine base
                         (await github.rest.pulls.get({ owner: repoOwner, repo: repoName, pull_number: issueNumber })).data.base.ref
                         : execSync('git symbolic-ref refs/remotes/origin/HEAD | sed "s@^refs/remotes/origin/@@"').toString().trim(), // Get default branch
                  body: body + `\n\nCloses #${issueNumber}`, // Link PR to issue
                });
                console.log(`Created Pull Request: ${pr.data.html_url}`);
                return pr.data.html_url;

              } catch (error) {
                console.error(`Failed to create pull request: ${error}`);
                await postComment(`âš ï¸ Error creating pull request: ${error.message}`);
                // Attempt to clean up the failed branch
                execSync(`git checkout ${execSync('git symbolic-ref refs/remotes/origin/HEAD | sed "s@^refs/remotes/origin/@@"').toString().trim()}`); // Back to default branch
                execSync(`git branch -D ${branchName} || true`); // Delete local branch if exists
                return null;
              }
            }

            async function addLabels(labels) {
                console.log(`Adding labels: ${labels.join(', ')}`);
                try {
                    await github.rest.issues.addLabels({
                        owner: repoOwner,
                        repo: repoName,
                        issue_number: issueNumber,
                        labels: labels,
                    });
                    console.log('Labels added successfully.');
                    return true;
                } catch (error) {
                    console.error(`Failed to add labels: ${error}`);
                    await postComment(`âš ï¸ Error adding labels (${labels.join(', ')}): ${error.message}`);
                    return false;
                }
            }


            // --- Main Logic ---

            // 1. Check if the bot was mentioned
            if (!commentBody || !commentBody.includes(botUsername)) {
              console.log('Bot was not mentioned. Skipping.');
              return;
            }
            console.log(`Bot mentioned by ${commenterLogin} in comment ${commentId}. Processing...`);

            // 2. Acknowledge the mention
            await addReaction('eyes');
            await postComment(`Hi @${commenterLogin}, I'm looking into that for you! ðŸ‘€`);

            // 3. Gather context for the AI
            const issueData = await github.rest.issues.get({
              owner: repoOwner,
              repo: repoName,
              issue_number: issueNumber
            });
            const issueTitle = issueData.data.title;
            const issueBody = issueData.data.body || ''; // Handle empty body

            const { data: comments } = await github.rest.issues.listComments({
              owner: repoOwner,
              repo: repoName,
              issue_number: issueNumber
            });

            // 4. Prepare messages for the AI
            const messages = [];
            let systemPrompt = "You are an AI assistant integrated into GitHub."; // Default prompt
            if (fs.existsSync(systemPromptPath)) {
                systemPrompt = fs.readFileSync(systemPromptPath, 'utf8');
            } else {
                console.warn(`System prompt file not found at ${systemPromptPath}. Using default.`);
                // Add instructions to default prompt if file is missing
                systemPrompt += "\nYou can analyze requests, read specified files, suggest code changes, create Pull Requests, and assign labels. \nTo request file content, respond ONLY with: `ACTION: READ_FILES: [\"path/to/file1.js\", \"path/to/file2.py\"]`\nTo propose a Pull Request, respond ONLY with: `ACTION: CREATE_PR: { \"branch\": \"feature/ai-suggestion\", \"title\": \"AI Suggestion for X\", \"body\": \"Description of changes...\", \"changes\": [{ \"file\": \"path/to/file.js\", \"content\": \"// New file content here...\" }] }`\nTo assign labels, respond ONLY with: `ACTION: ASSIGN_LABELS: [\"bug\", \"enhancement\"]`";
            }
            messages.push({ role: 'system', content: systemPrompt });

            // Add issue title and body as first user message
            messages.push({ role: 'user', content: `Issue Title: ${issueTitle}\n\n${issueBody}` });

            // Add comments to the history
            for (const comment of comments) {
              const role = comment.user.login === botUsername.substring(1) || comment.user.type === 'Bot' ? 'assistant' : 'user'; // Assuming bot name matches username
              // Make sure not to include the very comment that triggered this run if it was just the mention
              if (comment.id === commentId && role === 'user') {
                 messages.push({ role: 'user', content: `User @${comment.user.login} said: ${comment.body}` });
              } else if (comment.id !== commentId) {
                 messages.push({ role: role, content: comment.body });
              }
            }

            // 5. Call the AI API (Pollinations.ai or other)
            let aiResponseContent = '';
            try {
              console.log(`Sending ${messages.length} messages to AI: ${apiEndpoint}`);
              // *** Replace this fetch call with the specific requirements for pollinations.ai ***
              const response = await fetch(apiEndpoint, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${apiKey}` // Adjust auth scheme if needed
                },
                body: JSON.stringify({
                  // model: 'pollinations-model-name', // Specify model if required by API
                  messages: messages,
                  // max_tokens: 1000, // Add other parameters as needed
                  // temperature: 0.7,
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API request failed: ${response.status} ${errorText}`);
              }

              const data = await response.json();
              // Adjust based on the actual structure of the Pollinations.ai response
              if (!data.choices || data.choices.length === 0 || !data.choices[0].message || !data.choices[0].message.content) {
                   throw new Error('Invalid AI response structure received.');
              }
              aiResponseContent = data.choices[0].message.content;
              console.log("AI Response received.");

            } catch (error) {
              console.error('Error calling AI API:', error);
              await postComment(`Sorry @${commenterLogin}, I encountered an error trying to process your request: ${error.message}`);
              return; // Stop execution
            }


            // 6. Process AI response for Actions or standard reply
            let finalComment = ''; // Build the final comment to post

            // Check for READ_FILES action
            const readFilesMatch = aiResponseContent.match(/^ACTION:\s*READ_FILES:\s*(\[.*?\])/);
            if (readFilesMatch && readFilesMatch[1]) {
                try {
                    const filesToRead = JSON.parse(readFilesMatch[1]);
                    let fileContents = '';
                    let filesRead = [];
                    let filesFailed = [];
                    for (const file of filesToRead) {
                        try {
                           const content = readFileContent(file);
                           fileContents += `\n\n--- Content of ${file} ---\n${content}\n--- End of ${file} ---`;
                           filesRead.push(file);
                        } catch (fileError) {
                            console.warn(`Could not read file ${file}: ${fileError.message}`);
                            filesFailed.push(file);
                        }
                    }
                    // For now, just report what was read/failed. A more complex flow would re-prompt the AI.
                    finalComment = `Okay @${commenterLogin}, I need to examine these files. `;
                    if (filesRead.length > 0) {
                        finalComment += `I have read:\n\`\`\`\n${filesRead.join('\n')}\n\`\`\`\n`;
                        // VERY IMPORTANT: In a real scenario, you'd likely add `fileContents` to the `messages` array
                        // and make *another* call to the AI API here to get the *actual* analysis based on the files.
                        // This example stops short of that recursive call for simplicity.
                        finalComment += `\n(Content added to context for further analysis in the next step - if implemented).`; // Placeholder message
                    }
                    if (filesFailed.length > 0) {
                        finalComment += `\nI could not access:\n\`\`\`\n${filesFailed.join('\n')}\n\`\`\``;
                    }

                } catch (parseError) {
                    console.error("Failed to parse READ_FILES action:", parseError);
                    finalComment = `I tried to process a file read request but encountered an error. The raw response was:\n\`\`\`\n${aiResponseContent}\n\`\`\``;
                }

            // Check for CREATE_PR action
            } else if (aiResponseContent.startsWith('ACTION: CREATE_PR:')) {
                 try {
                    const prDataString = aiResponseContent.substring('ACTION: CREATE_PR:'.length).trim();
                    const prData = JSON.parse(prDataString);

                    if (!prData.branch || !prData.title || !prData.body || !prData.changes || !Array.isArray(prData.changes)) {
                        throw new Error("Invalid CREATE_PR data structure.");
                    }

                    const prUrl = await createPullRequest(prData.branch, prData.title, prData.body, prData.changes);
                    if (prUrl) {
                        finalComment = `Okay @${commenterLogin}, I've created a Pull Request for you: ${prUrl}`;
                    } else {
                        finalComment = `Sorry @${commenterLogin}, I attempted to create a Pull Request but encountered an error. Please check the Action logs.`;
                    }
                 } catch (parseError) {
                    console.error("Failed to parse CREATE_PR action:", parseError);
                    finalComment = `I tried to process a Pull Request creation request but encountered an error parsing the instructions. The raw response was:\n\`\`\`\n${aiResponseContent}\n\`\`\``;
                 }

            // Check for ASSIGN_LABELS action
            } else if (aiResponseContent.startsWith('ACTION: ASSIGN_LABELS:')) {
                try {
                    const labelsDataString = aiResponseContent.substring('ACTION: ASSIGN_LABELS:'.length).trim();
                    const labelsToAdd = JSON.parse(labelsDataString);

                    if (!Array.isArray(labelsToAdd)) {
                         throw new Error("Invalid ASSIGN_LABELS data structure.");
                    }

                    const success = await addLabels(labelsToAdd);
                    if (success) {
                        finalComment = `Okay @${commenterLogin}, I've added the following labels: ${labelsToAdd.join(', ')}`;
                    } else {
                        finalComment = `Sorry @${commenterLogin}, I attempted to add labels but encountered an error. Please check the Action logs.`;
                    }
                } catch (parseError) {
                    console.error("Failed to parse ASSIGN_LABELS action:", parseError);
                    finalComment = `I tried to process a label assignment request but encountered an error parsing the instructions. The raw response was:\n\`\`\`\n${aiResponseContent}\n\`\`\``;
                }

            // Default: Post the AI response as a comment
            } else {
              finalComment = aiResponseContent;
            }

            // 7. Post the final response/result
            if (finalComment) {
                 await postComment(finalComment);
            } else {
                 console.log("No final comment to post (e.g., only action performed without direct text response).");
            }
